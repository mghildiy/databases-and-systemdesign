# Design principles for data intensive applications

## Replication

Replication means keeping a copy of the same data on multiple machines that are connected via a network. As discussed in the introduction to Part II, there are several
reasons why you might want to replicate data:
- To keep data geographically close to your users (and thus reduce latency)
- To allow the system to continue working even if some of its parts have failed(and thus increase availability)
- To scale out the number of machines that can serve read queries (and thus increase read throughput)

If data doesn't change, we need to copy just once. But that rarely is the case as data keeps changing, and hence one
of the major difficulty in replication is to ensure that all nodes receive latest data. Added concerns involve
are to decide on synchronous vs asynchronous replication, and how to handle failed replicas.

Most common solution for data replication is _**master-slave/active-passive**_. 
- One of the replica is designated as master/leader and clients send write requests to leader only which first writes
  data to its local storage
- Other replicas are followers/slaves,and master/leader sends new writes to other replicas as part of replication log/change stream,
  and they apply these writes to their local storage in same order as processed by master
- A client can send read request to master as well as slaves

Many relational databases already use this replication approach, as well as message brokers like kafka.

### Asynchronous vs synchronous replication

![image](./images/leader-based-replication.png)

In image above, replication process follows synchronous approach with follower 1, and asynchronous approach with follower 2.

When a write request arrives at leader, it updates local storage and then sends the data to followers. With follower 1, leader
waits for confirmation and only after it is received, it sends success response to user and makes write visible to other users.
This approach has advantage that its guarantees that follower has same copy of data as leader,a nd if leader fails, follower can
be made leader. But if follower fails to respond due to network problems or due to failure of the node, leader has to block
all writes and wait till follower is available again.
With asynchronous replication with follower 2, master doesn't wait for response, and so data replication is not guaranteed.

It is impractical to make all followers synchronous because if one of the follower is unavailable, whole database system
would come to a halt. So a combination fo both approaches is preferred one. One of the follower is made synchronous while
others follow asynchronous replication. So if synchronous follower is unavailable or slow, one of the asynchronous follower
is made synchronous. This ensures that at a given time we have 2 up-to-date copies: master and synchronous follower.
Number of sync-async followers can be configured as per requirements.

### Handling node failures
Nodes in a distributed database system can go down due to machine failure, or due to maintenance. Few approaches are used
to make master-slave system highly available in case of node outages.

#### Follower failure: Catch-up recovery
When a failed follower node revives using the log from local storage, it detects the last transaction
it received from master, and so now it reconnects to master and requests all the writes which happened after that transaction.

#### Leader failure: Failover
Master/leader failure is much more complex than handling follower failure. A new leader has to be selected from the followers,
clients have to be reconfigured to now send writes to new leader, and followers now need to consume data from new leader.
This whole process is called **_Failover_**, and can be manual as well as automatic.
In automatic setup:
_ Leader failure is detected using health-checks
- New leader is elected using consensus algorithms, also taking into account which followers have most updated data
- Clients are reconfigure to send write requests to new leader
- If old leader comes back, it needs to be made a follower

Failover problems:
- One major issue in failover is that if new leader doesn't have the complete data from old leader, and it receives writes
which are conflicting with old leader then it may lead to data inconsistency issues, particularly if data is used by other systems.
For eg., suppose primary keys are generated using autoincrement strategy, then it may lead to a situation that new leader
generates primary keys already generated by old leader, but pointing to diff records. Any other system using those primary
keys would be impacted, like a cache system.
- Sometimes, we end up with 2 nodes as leaders, causing a scenario called _**split-brain**_. This may cause data loss or corrupt
  data.
- How to decide what is right timeout before a leader is declared dead? If it's too long, then system may be without a leader
  even if leader is actually dead, making it unavailable as well as leading to longer recovery times as new leader is selection is also
  delayed. If its to short, we may be having too frequent failovers happening even if leader is not dead, thus stressing the system unnecessarily.




# SQL
Order of execution in a SQL query:
- FROM [MyTable]
- ON [MyCondition]
- JOIN [MyJoinedTable]
- WHERE [...]
- GROUP BY [...]
- HAVING [...]
- SELECT [...]
- ORDER BY [...]
- LIMIT

- JOIN/INNER JOIN : Fetch all rows which match the join criteria
- LEFT JOIN: INNER JOIN + all other records from table on left of join
- RIGHT JOIN: INNER JOIN + all other records from table on right of join
- Multiple JOINS: Join initiated from left and progressively joins the result with next table

https://www.sqlshack.com/learn-sql-sql-query-practice/